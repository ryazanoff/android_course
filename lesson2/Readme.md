##Основы Java. Типы данных и операции над ними. ООП в Java: абстракция, инкапсуляция, наследование, полиморфизм.

[Скринкаст занятия](https://www.youtube.com/watch?v=CSjx5obOX3Y)

О типах данных и основных алгоритмических конструкциях (for, while, if ... ) я успел поговорить в скринкасте первого занятия. Данное занятие будет посвящено ООП в Java.
Программирование развивалось по следующему пути: последовательное -> процедурное -> ООП.

В последовательном мы просто пишем код в том порядке, в котором хотим, чтобы он исполнялся. В процедурном повторяющииеся куски кода стали выносить в блоки (процедуры).

Java  - объектно ориентированный язык программирования. 
Парадигма ООП - всё вокруг нас **объекты**. Каждый объект может иметь **свойства** (цвет, вес, запах , ... ) и **методы** (поведение объекта, например изменить цвет). Так же можно ввести понятие состояния объекта - это совокупность всех его полей.

Объекты существуют не самостоятельно, а лишь как экземпляр какого-то класса. Например у нас есть класс **Кафедра** и есть объекты этого класса **кафедра информатики**, **кафедра истории** и т.д. , которые отличаются друг от друга, но имеют общую структуру. 

Классы в Java (если они не внутренние) принято создавать в отдельном файле `ИмяКласса.java` . Приблизительная структура такого файла:

```java
package ru.ryazanoff.faceaday;  //Имя вашего пакета

import ClassA;
import ClassB;

public class ИмяКласса {  //имя класса с большой буквы и каждое слово с большой буквы
  public int свойствоОдин;
  public String свойствоДва; //имя с маленькой буквы, каждое новое слово с большой
  
  public void методОдин(){ //void ничего не возвращает, а лишь меняет свойства 
    //тело метода
  }
  
  public int методДва(){ //результат выполнения метода - int
    //тело метода
  }
  
}
```
Методы могут содержать параметры

```java
public int square(int a, int b) {
  return a*b;
}
```
В рамках одного класса может быть несколько методов с одним названием, но разными параметрами
```java
public int square(int a, int b) {
  return a*b;
}

public int square(int a) {
  return a*a;
}
```

Можно ввести методы с переменным числом параметров

```java
public static double getMaxValue(double... values) {
    double largest = Double.MIN_VALUE;
    for(double v : values) {
        if (v > largest) {
            largest = v;
        }
    }
    return largest;
}
```
Параметры метода, могут совпадать со свойствами класса, но тогда, чтобы из различить нужно использовать слово `this`.
```java
public class Class {  
  public int a;
  public int b; 
  
  public void changeAB(int a, int b){ 
    this.a = a;  //a - параметр, this.a - свойство
    this.b = b;
  }
  
}
```

###Конструктор
Создаёт экземпляр объекта. `Box b = new Box()`
Можно определить свой конструктор и даже несколько.
```java
public class Box {
  int width;
  int height;
  Box (int a, int b) {
    width = a;
    height = b;
  }
  
  Box (int a) {
    width = a;
    height = a;
  }
  
  //ИЛИ
  Box (int a) {
    this(a,a);
  }

}
```

###Парадигмы ООП
  1. Инкапсуляций
  2. Наследование
  3. Полиморфизм
  4. ~~Абстракция~~
Некоторые люди выделяют еще понятие абстракции, но по сути абстракция и есть наше представление всего в виде объектов, сгруппированных по классам. 


####Инкапсуляция
Принцип - внутреннее состояние объекта должно быть защищено от воздействий извне и должно производиться только с помощью методов. Почему инкапсуляция так важна? Этот принцип позволяет защитить переменные состояния объекта от неправильного их использования.
Это существенно ограничивает возможность введения объекта в недопустимое состояние и/или несанкционированное разрушение этого объекта. 

Любой дурак может написать программу понятную компьютеру. Только хороший программист пишет прогорамму понятную человкеку. Кроме того, программа должна быть читаема, если ты сядешь за нее через пару лет.
![На злобу дня](http://blog.myabc.ru/2012/02/chopchop.jpg "Читаем чужой код")


Достигается это с помощью свойств **public**, **protected** и **private** ,  которые указывают доступность метода, свойства или класса. 

Пример

```java
public class Box {  
  private int a;
  private int b; 
  protected int c;
  
  public int getSquare(){ 
    return a*b;
  }
  
}
```

|                                                                    | private | Модификатор не указан | protected | public |
|--------------------------------------------------------------------|---------|-----------------------|-----------|--------|
| В том же классе                                                    | Да      | Да                    | Да        | Да     |
| Подкласс класса этого же пакета                                    | Нет     | Да                    | Да        | Да     |
| Класс из общего пакета, не являющийся подклассом                   | Нет     | Да                    | Да        | Да     |
| Подкласс класса другого пакета                                     | Нет     | Нет                   | Да        | Да     |
| Класс другого пакета, не являющий подклассом класса данного пакета | Нет     | Нет                   | Нет       | Да     |

####Наследование
Позволяет создавать классы, похожие на наш класс. Класс наследник будет обладать всеми свойствами и методами класса родителя. Происходит с помощью слова `extends`.

```java
class Box {
    int width; // вес коробки
    int height;
    int depth;
    
    // конструктор
    Box(int w, int h, int d) {
        width = w;
        height = h;
        depth = d;
    }
}

class HeavyBox extends Box {
    int weight; // вес коробки
    
    // конструктор
    HeavyBox(int w, int h, int d, int m) {
        width = w;
        height = h;
        depth = d;
        weight = m; // масса
        
    }
}
```

#####super
Вызов конструктора или поля суперкласса (родителя)
```java
    HeavyBox(int w, int h, int d, int m) {  //конструктор
        super(w, h, d);
        weight = m; // масса
        
    }
```
Обращение к полям суперкласса
```java
class A {
    int i;
}

// наследуемся от класса A
class B extends A {
    int i; // имя переменной совпадает и скрывает переменную i в классе A
    
    B(int a, int b) {
        super.i = a; // обращаемся к переменной i из класса A
        i = b; // обращаемся к переменной i из класса B
    }
    
    void show() {
        System.out.println("i из суперкласса: " + super.i);
        System.out.println("i в подклассе: " + i);
    }
}

class MainActivity {
    B subClass = new B(1, 2);
    subClass.show();
}
```
Можно переопределять методы (не путать с перегрузкой). Тогда перед описанием нового метода должно быть `@Override`.

#####abstract
Метод, который описан в родителе, но не задано как он работает называется `абстрактным(abstract)` . Например если мы создадим класс животное, а у него метод "дышать", то мы не сможем его определить, т.к. все животные дышат по-разному. 

Если у класса есть хотя бы один абстрактный метод, то весь класс должен быть абстрактным. Абстрактный класс - экземпляр которого мы не можем создать. С другой стороны можно создать абстрактный класс и сделать в нем все методы не абстрактные. Когда создается новый класс, то нужно происать ВСЕ методы. Если хотя бы один метод не прописали, то надо сделать класс абстрактным. 

```java 
public abstract class Animal {
  private String name;
  public abstract void breath();
  public String getName() {
    return name;
  }
}
```

#####Интерфейс 
Интерфейс - класс у которого ВСЕ методы абстрактные. Он задает просто сигнатуры методов. В Java нет множественного наследования, но можно имплементить(implements) множество интерфейсов.  Интерфейс может наследоваться от другого интерфейса через ключевое слово extends.

```java 
public interface SimpleInterface {
	String getClassName();
	int getAge();
}
```

Основная проблема, почему нет ромбовидного наследования - проблема ромбовидного наследования. Множественное наслеодование усложняет код. Наследования от чужих классов (библиотек) тоже лучше не делать.

####Полиморфизм
Это возможность обращаться со всеми наследниками одинаковым образом.
Если мы имеем объекты, которые принадлежат одной и той же ветви иерархии (были унаследованы), то для них можно использовать единый интерфейс, который будет для каждого объекта производить однотипное действие, но результат для каждого объекта будет различным (зависящим от этого конкретного объекта).

Например, если мы при помощи наследования создадим серию роботов разных типов (робот, который варит кофе; робот, который моет пол; робот, который поливает цветы), а потом каждому роботу дадим команду «работай», то каждый робот в ответ на ту же самую команду будет делать различные действия, в соответствии с его типом. То есть, единым интерфейсом здесь является объект Robot с методом «работать», а то, как именно он будет работать, зависит от его реализации.

```java
class A {
   int x;
   int f(int a) {
      return a+x;
   }
   . . .
}

class B extends A {
   int y;

   int f(int s) {
       return s*x;
    }
   . . .
}

B b = new B();
A a = b;         // здесь происходит формальное преобразование типа: B => A
int c = a.f(10); // ??? какой из f(...) будет вызван ???
```
Правильны ответ - B.f();


#####final , static

[10 заметок о модификаторе Static в Java](http://info.javarush.ru/translation/2014/04/15/10-%D0%B7%D0%B0%D0%BC%D0%B5%D1%82%D0%BE%D0%BA-%D0%BE-%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D0%B5-Static-%D0%B2-Java.html)

В Java есть ключевое слово final , используемое как описатель полей, переменных, параметров и методов.

В применении к полям, переменным и параметрам оно означает, что их значение не может быть изменено. Поле или переменная с описателем final должны получить значение при описании, параметр просто не может быть изменен внутри тела метода.

```java
final double pi = 3.14;
```
Описатель final в сочетании с описателем static позволяют создать константы, т.е. поля, неизменные во всей программе. Так pi логичнее было бы описать так.
```java
static final double pi = 3.14;
```

Если нужно запретить переопределение (overriding) метода во всех порожденных классах, то этот метод можно описать как final.

Кроме того, ключевое слово final может применяться к классам. Это означает, что данный класс не может быть унаследован другим классом.

###UML
[Подробнее про UML](http://habrahabr.ru/post/150041/)
UML диаграммы удобно создавать с помощью https://www.draw.io/

###Задание
1. Заботать парадигмы ООП в копцепции Java
2. Почитать про UML и Составить диаграмму классов своего проекта



