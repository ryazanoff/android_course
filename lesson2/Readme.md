##Основы Java. Типы данных и операции над ними. ООП в Java: абстракция, инкапсуляция, наследование, полиморфизм.

О типах данных и основных алгоритмических конструкциях (for, while, if ... ) я успел поговорить в скринкасте первого занятия. Данное занятие будет посвящено ООП в Java.
Программирование развивалось по следующему пути: последовательное -> процедурное -> ООП.
В последовательно мы просто пишем код в том порядке, в котором хотим, чтобы он исполнялся. В процедурном повторяющииеся куски кода стали выносить в блоки (процедуры).

Java  - объектно ориентированный язык программирования. 
Парадигма ООП - всё вокруг нас **объекты**. Каждый объект может иметь **свойства** (цвет, вес, запах , ... ) и **методы** (поведение объекта, например изменить цвет). Так же можно ввести понятие состояния объекта - это совокупность всех его полей.

Объекты существуют не самостоятельно, а лишь как экземпляр какого-то класса. Например у нас есть класс **Кафедра** и есть объекты этого класса **кафедра информатики**, **кафедра истории** и т.д. , которые отличаются друг от друга, но имеют общую структуру. 

Классы в Java (если они не внутренние) принято создавать в отдельном файле `ИмяКласса.java` . Приблизительная структура такого файла:

```java
package ru.ryazanoff.faceaday;  //Имя вашего пакета

import ClassA;
import ClassB;

public class ИмяКласса {  //имя класса с большой буквы и каждое слово с большой буквы
  public int свойствоОдин;
  public String свойствоДва; //имя с маленькой буквы, каждое новое слово с большой
  
  public void методОдин(){ //void ничего не возвращает, а лишь меняет свойства 
    //тело метода
  }
  
  public int методДва(){ //результат выполнения метода - int
    //тело метода
  }
  
}
```
Методы могут содержать параметры

```java
public int square(int a, int b) {
  return a*b;
}
```
В рамках одного класса может быть несколько методов с одним названием, но разными параметрами
```java
public int square(int a, int b) {
  return a*b;
}

public int square(int a) {
  return a*a;
}
```

Можно ввести методы с переменным числом параметров

```java
public static double getMaxValue(double... values) {
    double largest = Double.MIN_VALUE;
    for(double v : values) {
        if (v > largest) {
            largest = v;
        }
    }
    return largest;
}
```
Параметры метода, могут совпадать со свойствами класса, но тогда, чтобы из различить нужно использовать слово `this`.
```java
public class Class {  
  public int a;
  public int b; 
  
  public void changeAB(int a, int b){ 
    this.a = a;  //a - параметр, this.a - свойство
    this.b = b;
  }
  
}
```

###Конструктор
Создаёт экземпляр объекта. `Box b = new Box()`
Можно определить свой конструктор и даже несколько.
```java
public class Box {
  int width;
  int height;
  Box (int a, int b) {
    width = a;
    height = b;
  }
  
  Box (int a) {
    width = a;
    height = a;
  }
  
  //ИЛИ
  Box (int a) {
    this(a,a);
  }

}
```

###Парадигмы ООП
  1. Инкапсуляций
  2. Наследование
  3. Полиморфизм
  4. ~~Абстракция~~
Некоторые люди выделяют еще понятие абстракции, но по сути абстракция и есть наше представление всего в виде объектов, сгруппированных по классам. 


####Инкапсуляция
Принцип - внутреннее состояние объекта должно быть защищено от воздействий извне и должно производиться только с помощью методов. Почему инкапсуляция так важна? Этот принцип позволяет защитить переменные состояния объекта от неправильного их использования.
Это существенно ограничивает возможность введения объекта в недопустимое состояние и/или несанкционированное разрушение этого объекта. 

Любой дурак может написать программу понятную компьютеру. Только хороший программист пишет прогорамму понятную человкеку. Кроме того, программа должна быть читаема, если ты сядешь за нее через пару лет.
![На злобу дня](http://blog.myabc.ru/2012/02/chopchop.jpg "Читаем чужой код")


Достигается это с помощью свойств **public**, **protected** и **private** ,  которые указывают доступность метода, свойства или класса. 

Пример

```java
public class Box {  
  private int a;
  private int b; 
  protected int c;
  
  public int getSquare(){ 
    return a*b;
  }
  
}
```

|                                                                    | private | Модификатор не указан | protected | public |
|--------------------------------------------------------------------|---------|-----------------------|-----------|--------|
| В том же классе                                                    | Да      | Да                    | Да        | Да     |
| Подкласс класса этого же пакета                                    | Нет     | Да                    | Да        | Да     |
| Класс из общего пакета, не являющийся подклассом                   | Нет     | Да                    | Да        | Да     |
| Подкласс класса другого пакета                                     | Нет     | Нет                   | Да        | Да     |
| Класс другого пакета, не являющий подклассом класса данного пакета | Нет     | Нет                   | Нет       | Да     |

####Наследование
Позволяет создавать классы, похожие на наш класс. Класс наследник будет обладать всеми свойствами и методами класса родителя. Происходит с помощью слова `extends`.

```java
class Box {
    int width; // вес коробки
    int height;
    int depth;
    
    // конструктор
    HeavyBox(int w, int h, int d) {
        width = w;
        height = h;
        depth = d;
    }
}

class HeavyBox extends Box {
    int weight; // вес коробки
    
    // конструктор
    HeavyBox(int w, int h, int d, int m) {
        width = w;
        height = h;
        depth = d;
        weight = m; // масса
        
    }
}
```

#####super
Вызов конструктора или поля суперкласса (родителя)
```java
    HeavyBox(int w, int h, int d, int m) {  //конструктор
        super(w, h, d);
        weight = m; // масса
        
    }
```
Обращение к полям суперкласса
```java
class A {
    int i;
}

// наследуемся от класса A
class B extends A {
    int i; // имя переменной совпадает и скрывает переменную i в классе A
    
    B(int a, int b) {
        super.i = a; // обращаемся к переменной i из класса A
        i = b; // обращаемся к переменной i из класса B
    }
    
    void show() {
        System.out.println("i из суперкласса: " + super.i);
        System.out.println("i в подклассе: " + i);
    }
}

class MainActivity {
    B subClass = new B(1, 2);
    subClass.show();
}
```
Можно переопределять методы (не путать с перегрузкой). Тогда перед описанием нового метода должно быть `@Override`.

#####abstract
Метод, который описан в родителе, но не задано как он работает называется `абстрактным(abstract)` . Например если мы создадим класс животное, а у него метод "дышать", то мы не сможем его определить, т.к. все животные дышат по-разному. 

Если у класса есть хотя бы один абстрактный метод, то весь класс должен быть абстрактным. Абстрактный класс - экземпляр которого мы не можем создать. С другой стороны можно создать абстрактный класс и сделать в нем все методы не абстрактные. 

```java 
public abstract class Animal {
  private String name;
  public abstract void breath();
  public String getName() {
    return name;
  }
}
```

Интерфейс - класс у которого ВСЕ методы абстрактные. Он задает просто сигнатуры методов. Множественного наследования нет, но можно множество интерфейсов . (extends 1 , implenets много , т.е. много имплементаций)
Когда создается новый класс, то нужно происать ВСЕ методы. Если хотя бы один метод не прописали, то надо сделать класс абстрактным. 

Основная проблема, почему нет ромбовидного наследования - проблема ромбовидного наследования. Множественное наслеодование усложняет код.

А зачем много интерфейсов? Отдельным классам можно сказать, что они имплементируют. Дерево наследования лучше вести снизу.

Наследоваться от чужих классов (библиотек) лучше не делать




